
3. 功能模块结构

3.1 Rust 核心库（logic_core）

职责：
	•	只负责逻辑，不依赖 Tauri/前端。

主要功能：
	1.	求解器（solver）
	•	输入：当前棋盘状态 + 方块使用情况。
	•	输出：
	•	是否有解；
	•	一条完整解（每个方块的位置与方向）。
	•	算法：
	•	朴素 DFS 回溯；
	•	每步选棋盘中的第一个空格；
	•	尝试所有未使用方块及其两种方向（w×h、h×w）。
	2.	唯一解检测
	•	在 DFS 中计数，最多搜索两解：
	•	0 解：无解；
	•	1 解：唯一解；
	•	≥2 解：多解。
	3.	简单关卡生成
	•	步骤：
	1.	从空棋盘 + 11 块生成一个完整铺满的终局解；
	2.	从终局随机选若干块作为“预放块”，生成关卡；
	3.	用求解器确认关卡有解（可选：唯一解）。
	4.	数据结构（简要）
	•	棋盘：8×8，使用 64 长度数组，值：
	•	-1 = 障碍；
	•	0  = 空；
	•	>0 = 某块的 piece_id。
	•	方块：id, width, height, rotatable, color。
	•	关卡：初始棋盘 + 标准 11 方块 + 可选难度信息。

⸻

3.2 Tauri 后端（Rust）

职责：
	•	作为桥梁，将前端请求转发给 logic_core，返回 JSON 结果。

需要暴露的命令（示例）：
	1.	new_random_level(config)
	•	生成或加载一局新关卡；
	•	返回：关卡数据（初始棋盘 + 方块定义等）。
	2.	solve_level(state)
	•	输入：当前棋盘状态（包含玩家已摆放的块）；
	•	输出：
	•	has_solution: bool
	•	如有解：返回完整解的棋盘或方块摆放列表。
	3.	check_state(state)（可选）
	•	检查当前状态是否仍有解（是否走进死路）；
	•	返回布尔值和简单提示。


⸻

3.3 前端（HTML/CSS/TypeScript）

职责：
	•	展示棋盘与方块，处理玩家交互，调用 Tauri 命令。

主要功能：
	1.	棋盘显示
	•	显示 8×8 格子；
	•	根据 board 数组渲染障碍、空格、已占用格；
	•	按 piece_id 和 color 高亮不同方块（颜色来自方块定义）。
	2.	方块托盘
	•	显示 11 个方块；
	•	标记已使用 / 未使用；
	•	支持选中方块、旋转方块（切换朝向）。
	3.	交互方式（简单版）
	•	点击托盘中的方块 → 选中；
	•	按按钮或键盘旋转该方块；
	•	点击棋盘格 → 尝试以该格为左上角放置当前方块；
	•	如果合法，更新本地状态；
	•	提供“撤销一步”功能（本地堆栈即可）。
	4.	按钮功能
	•	“新关卡” → 调 new_random_level；
	•	“重置” → 恢复到关卡初始状态；
	•	“求解” → 调 solve_level，用返回结果填满棋盘；
	•	“检查当前状态”（可选） → 调 check_state 给玩家提示。

⸻

4. 数据约定（仅供参考，不需要按照这个做）
	•	棋盘：board: number[64]
	•	索引 0–63 映射到行列：row = idx / 8, col = idx % 8。
	•	方块列表：固定 11 个，字段包括 id, width, height, rotatable, color。
	•	前端状态：
	•	以 board + “哪些方块已经放置” 为主；
	•	调用求解/检查时，把当前状态打包为 JSON 传给 Tauri。

⸻


⸻